<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Graph Sense — Intuition Trainer</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Graph Sense">
<meta name="mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#0a0f0a">
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icon-192.png">
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;600;700&display=swap');
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    min-height: 100vh;
    min-height: -webkit-fill-available;
    background: #0a0f0a;
    color: #c0d8c0;
    font-family: 'JetBrains Mono', 'Fira Code', 'SF Mono', monospace;
    padding: 20px;
    padding-top: calc(20px + env(safe-area-inset-top));
    padding-bottom: calc(20px + env(safe-area-inset-bottom));
    -webkit-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
    overscroll-behavior: none;
  }
  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: #0a0f0a; }
  ::-webkit-scrollbar-thumb { background: #2d4a2d; border-radius: 3px; }

  .container { max-width: 520px; margin: 0 auto; }

  .header { margin-bottom: 24px; display: flex; justify-content: space-between; align-items: center; }
  .header h1 { font-size: 18px; color: #00ff88; font-weight: 700; letter-spacing: 2px; }
  .header .sub { font-size: 10px; color: #4a6a4a; margin-top: 2px; letter-spacing: 1px; }

  .btn {
    background: none; border: 1px solid #2d4a2d; color: #4a6a4a;
    padding: 6px 12px; cursor: pointer; font-family: inherit; font-size: 11px; border-radius: 2px;
  }
  .btn:hover { border-color: #4a6a4a; color: #6a8a6a; }

  .settings {
    border: 1px solid #1a2a1a; padding: 16px; margin-bottom: 20px; background: #0d130d;
    display: none;
  }
  .settings.open { display: block; }
  .settings-label { font-size: 10px; color: #4a6a4a; margin-bottom: 10px; letter-spacing: 1px; }
  .cat-buttons { display: flex; flex-wrap: wrap; gap: 6px; }
  .cat-btn {
    background: transparent; border: 1px solid #1a2a1a; color: #3a5a3a;
    padding: 4px 10px; cursor: pointer; font-family: inherit; font-size: 10px; border-radius: 2px;
  }
  .cat-btn.active { background: #1a3a1a; border-color: #00ff88; color: #00ff88; }

  .stats-bar {
    display: flex; gap: 16px; margin-bottom: 16px; font-size: 10px; color: #4a6a4a;
    border-bottom: 1px solid #1a2a1a; padding-bottom: 10px;
  }
  .stats-bar .g { color: #00ff88; }
  .stats-bar .o { color: #ff6b35; }

  .problem-header {
    text-align: center; padding: 16px 0; margin-bottom: 12px; border-bottom: 1px solid #1a2a1a;
  }
  .problem-cat { font-size: 10px; color: #4a6a4a; margin-bottom: 6px; letter-spacing: 1px; }
  .problem-eq { font-size: 22px; color: #e0f0e0; font-weight: 300; }
  .problem-hint { font-size: 10px; color: #2d4a2d; margin-top: 8px; }

  .canvas-wrap {
    border: 1px solid #1a2a1a; margin-bottom: 12px; background: #0d130d;
    display: flex; justify-content: center;
  }
  #graphCanvas { width: 100%; max-width: 460px; cursor: crosshair; touch-action: none; }

  .legend { display: flex; gap: 20px; justify-content: center; margin-bottom: 12px; font-size: 11px; }
  .legend .sketch-color { color: #ff6b35; }
  .legend .actual-color { color: #00ff88; }

  .controls { display: flex; gap: 8px; margin-bottom: 16px; }
  .ctrl-btn {
    flex: 1; padding: 10px 0; background: transparent; border: 1px solid #2d4a2d;
    color: #4a6a4a; cursor: pointer; font-family: inherit; font-size: 11px; border-radius: 2px;
  }
  .ctrl-btn.primary {
    flex: 2; background: #1a3a1a; border-color: #00ff88; color: #00ff88; font-weight: 600;
  }
  .ctrl-btn.next {
    flex: 1; background: #1a3a1a; border-color: #00ff88; color: #00ff88;
    font-weight: 600; font-size: 12px; letter-spacing: 1px;
  }

  .rate-label { font-size: 10px; color: #4a6a4a; margin-bottom: 8px; text-align: center; letter-spacing: 1px; }
  .rate-buttons { display: flex; gap: 6px; }
  .rate-btn {
    flex: 1; padding: 10px 0; cursor: pointer; font-family: inherit; font-size: 13px;
    font-weight: 600; border-radius: 2px;
  }
  .rate-btn.low { background: #2a1515; border: 1px solid #ff4444; color: #ff6b6b; }
  .rate-btn.mid { background: #2a2a15; border: 1px solid #aaaa44; color: #cccc66; }
  .rate-btn.high { background: #152a15; border: 1px solid #00ff88; color: #00ff88; }

  .breakdown {
    border: 1px solid #1a2a1a; padding: 12px; background: #0d130d; display: none;
  }
  .breakdown.open { display: block; }
  .breakdown-label { font-size: 10px; color: #4a6a4a; margin-bottom: 8px; letter-spacing: 1px; }
  .breakdown-row { display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 4px; }
  .breakdown-row .name { color: #6a8a6a; }
  .breakdown-row .count { color: #4a6a4a; }

  .hidden { display: none !important; }
</style>
</head>
<body>

<div class="container">
  <div class="header">
    <div>
      <h1>GRAPH SENSE</h1>
      <div class="sub">INTUITION TRAINER</div>
    </div>
    <button class="btn" id="configBtn">CONFIG</button>
  </div>

  <div class="settings" id="settings">
    <div class="settings-label" id="catCount"></div>
    <div class="cat-buttons" id="catButtons"></div>
  </div>

  <div class="stats-bar hidden" id="statsBar">
    <span>DONE: <span class="g" id="statTotal"></span></span>
    <span>AVG: <span id="statAvg"></span></span>
    <span id="statL10Wrap" class="hidden">L10: <span id="statL10"></span></span>
  </div>

  <div class="problem-header">
    <div class="problem-cat" id="probCat"></div>
    <div class="problem-eq" id="probEq"></div>
    <div class="problem-hint" id="probHint">sketch your prediction, then reveal</div>
  </div>

  <div class="canvas-wrap">
    <canvas id="graphCanvas" width="460" height="400"></canvas>
  </div>

  <div class="legend hidden" id="legend">
    <span><span class="sketch-color">━━</span> your sketch</span>
    <span><span class="actual-color">━━</span> actual</span>
  </div>

  <div class="controls" id="controls">
    <button class="ctrl-btn" id="clearBtn">CLEAR</button>
    <button class="ctrl-btn primary" id="revealBtn">REVEAL</button>
  </div>

  <div class="hidden" id="rateSection" style="margin-bottom:16px;">
    <div class="rate-label">RATE YOUR ACCURACY</div>
    <div class="rate-buttons" id="rateButtons"></div>
  </div>

  <div class="hidden" id="nextSection" style="margin-bottom:16px;">
    <button class="ctrl-btn next" id="nextBtn" style="width:100%">NEXT →</button>
  </div>

  <div class="breakdown" id="breakdown">
    <div class="breakdown-label">BREAKDOWN</div>
    <div id="breakdownRows"></div>
  </div>
</div>

<script>
const CATEGORIES = {
  linear: {
    name: "Linear",
    generate() {
      const ms = [-3,-2,-1,-0.5,0.5,1,2,3], bs = [-3,-2,-1,0,1,2,3];
      const m = ms[Math.floor(Math.random()*ms.length)];
      const b = bs[Math.floor(Math.random()*bs.length)];
      const bS = b===0?"":b>0?` + ${b}`:` - ${Math.abs(b)}`;
      const mS = m===1?"":m===-1?"-":m;
      return { equation:`f(x) = ${mS}x${bS}`, fn:x=>m*x+b, domain:[-6,6], range:[-6,6] };
    }
  },
  quadratic: {
    name: "Quadratic",
    generate() {
      const as=[-2,-1,-0.5,0.5,1,2], hs=[-3,-2,-1,0,1,2,3], ks=[-3,-2,-1,0,1,2,3];
      const a=as[Math.floor(Math.random()*as.length)];
      const h=hs[Math.floor(Math.random()*hs.length)];
      const k=ks[Math.floor(Math.random()*ks.length)];
      const aS=a===1?"":a===-1?"-":a;
      const hS=h===0?"x":h>0?`(x - ${h})`:`(x + ${Math.abs(h)})`;
      const kS=k===0?"":k>0?` + ${k}`:` - ${Math.abs(k)}`;
      return { equation:`f(x) = ${aS}${hS}²${kS}`, fn:x=>a*(x-h)**2+k, domain:[-6,6], range:[-8,8] };
    }
  },
  cubic: {
    name: "Cubic",
    generate() {
      const as=[-1,-0.5,0.5,1], hs=[-2,-1,0,1,2], ks=[-2,-1,0,1,2];
      const a=as[Math.floor(Math.random()*as.length)];
      const h=hs[Math.floor(Math.random()*hs.length)];
      const k=ks[Math.floor(Math.random()*ks.length)];
      const aS=a===1?"":a===-1?"-":a;
      const hS=h===0?"x":h>0?`(x - ${h})`:`(x + ${Math.abs(h)})`;
      const kS=k===0?"":k>0?` + ${k}`:` - ${Math.abs(k)}`;
      return { equation:`f(x) = ${aS}${hS}³${kS}`, fn:x=>a*(x-h)**3+k, domain:[-5,5], range:[-8,8] };
    }
  },
  sqrt: {
    name: "Square Root",
    generate() {
      const as=[-2,-1,1,2], hs=[-3,-2,-1,0,1,2,3], ks=[-2,-1,0,1,2];
      const a=as[Math.floor(Math.random()*as.length)];
      const h=hs[Math.floor(Math.random()*hs.length)];
      const k=ks[Math.floor(Math.random()*ks.length)];
      const aS=a===1?"":a===-1?"-":a;
      const inner=h===0?"x":h>0?`(x - ${h})`:`(x + ${Math.abs(h)})`;
      const kS=k===0?"":k>0?` + ${k}`:` - ${Math.abs(k)}`;
      return { equation:`f(x) = ${aS}√${inner}${kS}`, fn:x=>(x-h>=0?a*Math.sqrt(x-h)+k:NaN), domain:[-6,6], range:[-6,6] };
    }
  },
  abs: {
    name: "Absolute Value",
    generate() {
      const as=[-2,-1,-0.5,0.5,1,2], hs=[-3,-2,-1,0,1,2,3], ks=[-3,-2,-1,0,1,2,3];
      const a=as[Math.floor(Math.random()*as.length)];
      const h=hs[Math.floor(Math.random()*hs.length)];
      const k=ks[Math.floor(Math.random()*ks.length)];
      const aS=a===1?"":a===-1?"-":a;
      const inner=h===0?"x":h>0?`x - ${h}`:`x + ${Math.abs(h)}`;
      const kS=k===0?"":k>0?` + ${k}`:` - ${Math.abs(k)}`;
      return { equation:`f(x) = ${aS}|${inner}|${kS}`, fn:x=>a*Math.abs(x-h)+k, domain:[-6,6], range:[-6,6] };
    }
  },
  rational: {
    name: "Rational (1/x)",
    generate() {
      const as=[-2,-1,1,2], hs=[-3,-2,-1,0,1,2,3], ks=[-2,-1,0,1,2];
      const a=as[Math.floor(Math.random()*as.length)];
      const h=hs[Math.floor(Math.random()*hs.length)];
      const k=ks[Math.floor(Math.random()*ks.length)];
      const denom=h===0?"x":h>0?`(x - ${h})`:`(x + ${Math.abs(h)})`;
      const kS=k===0?"":k>0?` + ${k}`:` - ${Math.abs(k)}`;
      return { equation:`f(x) = ${a}/${denom}${kS}`, fn:x=>(Math.abs(x-h)<0.01?NaN:a/(x-h)+k), domain:[-8,8], range:[-8,8] };
    }
  },
  exponential: {
    name: "Exponential",
    generate() {
      const bases=[2,3,0.5], as=[-1,1], ks=[-2,-1,0,1,2], hs=[-2,-1,0,1,2];
      const base=bases[Math.floor(Math.random()*bases.length)];
      const a=as[Math.floor(Math.random()*as.length)];
      const k=ks[Math.floor(Math.random()*ks.length)];
      const h=hs[Math.floor(Math.random()*hs.length)];
      const aS=a===1?"":"-";
      const bS=base===0.5?"(1/2)":base;
      const exp=h===0?"x":h>0?`(x-${h})`:`(x+${Math.abs(h)})`;
      const kS=k===0?"":k>0?` + ${k}`:` - ${Math.abs(k)}`;
      return { equation:`f(x) = ${aS}${bS}^${exp}${kS}`, fn:x=>a*base**(x-h)+k, domain:[-5,5], range:[-6,10] };
    }
  },
  log: {
    name: "Logarithmic",
    generate() {
      const as=[-1,1,2], hs=[-2,-1,0,1,2], ks=[-2,-1,0,1,2];
      const a=as[Math.floor(Math.random()*as.length)];
      const h=hs[Math.floor(Math.random()*hs.length)];
      const k=ks[Math.floor(Math.random()*ks.length)];
      const aS=a===1?"":a===-1?"-":a;
      const inner=h===0?"x":h>0?`(x - ${h})`:`(x + ${Math.abs(h)})`;
      const kS=k===0?"":k>0?` + ${k}`:` - ${Math.abs(k)}`;
      return { equation:`f(x) = ${aS}ln${inner}${kS}`, fn:x=>(x-h>0?a*Math.log(x-h)+k:NaN), domain:[-2,8], range:[-6,6] };
    }
  },
  trig: {
    name: "Trigonometric",
    generate() {
      const types=["sin","cos"];
      const type=types[Math.floor(Math.random()*2)];
      const as=[-2,-1,1,2], bs=[1,2,0.5], ks=[-1,0,1];
      const a=as[Math.floor(Math.random()*as.length)];
      const b=bs[Math.floor(Math.random()*bs.length)];
      const k=ks[Math.floor(Math.random()*ks.length)];
      const aS=a===1?"":a===-1?"-":a;
      const bS=b===1?"":b;
      const kS=k===0?"":k>0?` + ${k}`:` - ${Math.abs(k)}`;
      const trigFn=type==="sin"?Math.sin:Math.cos;
      return { equation:`f(x) = ${aS}${type}(${bS}x)${kS}`, fn:x=>a*trigFn(b*x)+k, domain:[-7,7], range:[-4,4] };
    }
  }
};

// State
let activeCategories = {};
Object.keys(CATEGORIES).forEach(k => activeCategories[k] = true);
let problem = null;
let showGraph = false;
let drawingPoints = [];
let isDrawing = false;
let selfScore = null;
let history = [];
let settingsOpen = false;

// DOM refs
const canvas = document.getElementById('graphCanvas');
const ctx = canvas.getContext('2d');
const W = 460, H = 400, pad = 40;

// Coordinate transforms
function toCanvasX(x) { return pad + ((x - problem.domain[0]) / (problem.domain[1] - problem.domain[0])) * (W - 2*pad); }
function toCanvasY(y) { return H - pad - ((y - problem.range[0]) / (problem.range[1] - problem.range[0])) * (H - 2*pad); }
function fromCanvasX(cx) { return problem.domain[0] + ((cx - pad) / (W - 2*pad)) * (problem.domain[1] - problem.domain[0]); }
function fromCanvasY(cy) { return problem.range[0] + ((H - pad - cy) / (H - 2*pad)) * (problem.range[1] - problem.range[0]); }

function draw() {
  if (!problem) return;
  ctx.clearRect(0, 0, W, H);
  const domain = problem.domain, range = problem.range;

  // Grid
  ctx.strokeStyle = '#1a2a1a'; ctx.lineWidth = 0.5;
  const xStep = (domain[1]-domain[0]) <= 10 ? 1 : 2;
  const yStep = (range[1]-range[0]) <= 10 ? 1 : 2;
  for (let x = Math.ceil(domain[0]); x <= domain[1]; x += xStep) {
    ctx.beginPath(); ctx.moveTo(toCanvasX(x), pad); ctx.lineTo(toCanvasX(x), H-pad); ctx.stroke();
  }
  for (let y = Math.ceil(range[0]); y <= range[1]; y += yStep) {
    ctx.beginPath(); ctx.moveTo(pad, toCanvasY(y)); ctx.lineTo(W-pad, toCanvasY(y)); ctx.stroke();
  }

  // Axes
  ctx.strokeStyle = '#2d4a2d'; ctx.lineWidth = 1.5;
  const ox = toCanvasX(0), oy = toCanvasY(0);
  if (ox >= pad && ox <= W-pad) { ctx.beginPath(); ctx.moveTo(ox, pad); ctx.lineTo(ox, H-pad); ctx.stroke(); }
  if (oy >= pad && oy <= H-pad) { ctx.beginPath(); ctx.moveTo(pad, oy); ctx.lineTo(W-pad, oy); ctx.stroke(); }

  // Labels
  ctx.fillStyle = '#4a6a4a'; ctx.font = "10px 'JetBrains Mono', monospace"; ctx.textAlign = 'center';
  for (let x = Math.ceil(domain[0]); x <= domain[1]; x += xStep) {
    if (x === 0) continue;
    ctx.fillText(x, toCanvasX(x), H-pad+14);
  }
  ctx.textAlign = 'right';
  for (let y = Math.ceil(range[0]); y <= range[1]; y += yStep) {
    if (y === 0) continue;
    ctx.fillText(y, pad-6, toCanvasY(y)+3);
  }

  // User sketch
  if (drawingPoints.length > 1) {
    ctx.strokeStyle = '#ff6b35'; ctx.lineWidth = 2.5; ctx.setLineDash([]);
    ctx.beginPath(); ctx.moveTo(drawingPoints[0].cx, drawingPoints[0].cy);
    for (let i = 1; i < drawingPoints.length; i++) ctx.lineTo(drawingPoints[i].cx, drawingPoints[i].cy);
    ctx.stroke();
  }

  // Actual graph
  if (showGraph && problem.fn) {
    ctx.strokeStyle = '#00ff88'; ctx.lineWidth = 2.5; ctx.setLineDash([]);
    ctx.beginPath();
    let started = false;
    const steps = 500;
    for (let i = 0; i <= steps; i++) {
      const x = domain[0] + (i/steps)*(domain[1]-domain[0]);
      const y = problem.fn(x);
      if (isNaN(y) || !isFinite(y) || y < range[0]-5 || y > range[1]+5) { started = false; continue; }
      const cx = toCanvasX(x), cy = toCanvasY(y);
      if (!started) { ctx.moveTo(cx, cy); started = true; } else { ctx.lineTo(cx, cy); }
    }
    ctx.stroke();
  }

  // Border
  ctx.strokeStyle = '#2d4a2d'; ctx.lineWidth = 1; ctx.setLineDash([]);
  ctx.strokeRect(pad, pad, W-2*pad, H-2*pad);
}

function getPos(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = W / rect.width, scaleY = H / rect.height;
  let clientX, clientY;
  if (e.touches) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
  else { clientX = e.clientX; clientY = e.clientY; }
  const cx = (clientX - rect.left) * scaleX, cy = (clientY - rect.top) * scaleY;
  return { cx, cy };
}

canvas.addEventListener('mousedown', e => { e.preventDefault(); if (showGraph) return; isDrawing = true; drawingPoints = [getPos(e)]; draw(); });
canvas.addEventListener('mousemove', e => { e.preventDefault(); if (!isDrawing || showGraph) return; drawingPoints.push(getPos(e)); draw(); });
canvas.addEventListener('mouseup', e => { e.preventDefault(); isDrawing = false; });
canvas.addEventListener('mouseleave', () => { isDrawing = false; });
canvas.addEventListener('touchstart', e => { e.preventDefault(); if (showGraph) return; isDrawing = true; drawingPoints = [getPos(e)]; draw(); });
canvas.addEventListener('touchmove', e => { e.preventDefault(); if (!isDrawing || showGraph) return; drawingPoints.push(getPos(e)); draw(); });
canvas.addEventListener('touchend', e => { e.preventDefault(); isDrawing = false; });

// UI updates
function updateUI() {
  // Stats
  const statsBar = document.getElementById('statsBar');
  if (history.length > 0) {
    statsBar.classList.remove('hidden');
    document.getElementById('statTotal').textContent = history.length;
    const avg = (history.reduce((s,h) => s+h.score, 0) / history.length).toFixed(1);
    const avgEl = document.getElementById('statAvg');
    avgEl.textContent = avg + '/5';
    avgEl.className = parseFloat(avg) >= 3 ? 'g' : 'o';
    if (history.length >= 10) {
      const l10 = (history.slice(0,10).reduce((s,h) => s+h.score, 0) / 10).toFixed(1);
      document.getElementById('statL10Wrap').classList.remove('hidden');
      const l10El = document.getElementById('statL10');
      l10El.textContent = l10 + '/5';
      l10El.className = parseFloat(l10) >= 3 ? 'g' : 'o';
    }
  } else { statsBar.classList.add('hidden'); }

  // Problem
  document.getElementById('probCat').textContent = CATEGORIES[problem.category].name.toUpperCase();
  document.getElementById('probEq').textContent = problem.equation;
  document.getElementById('probHint').classList.toggle('hidden', showGraph);

  // Legend
  document.getElementById('legend').classList.toggle('hidden', !(showGraph && drawingPoints.length > 0));

  // Controls
  document.getElementById('controls').classList.toggle('hidden', showGraph);
  document.getElementById('rateSection').classList.toggle('hidden', !(showGraph && selfScore === null));
  document.getElementById('nextSection').classList.toggle('hidden', !(showGraph && selfScore !== null));

  // Canvas cursor
  canvas.style.cursor = showGraph ? 'default' : 'crosshair';

  // Breakdown
  updateBreakdown();
}

function updateBreakdown() {
  const el = document.getElementById('breakdown');
  if (!settingsOpen || history.length === 0) { el.classList.remove('open'); return; }
  const byCategory = {};
  Object.keys(CATEGORIES).forEach(cat => {
    const items = history.filter(h => h.category === cat);
    if (items.length > 0) byCategory[cat] = { count: items.length, avg: (items.reduce((s,h)=>s+h.score,0)/items.length).toFixed(1) };
  });
  if (Object.keys(byCategory).length <= 1) { el.classList.remove('open'); return; }
  el.classList.add('open');
  document.getElementById('breakdownRows').innerHTML = Object.entries(byCategory).map(([cat, data]) =>
    `<div class="breakdown-row"><span class="name">${CATEGORIES[cat].name}</span><span><span class="count">${data.count}× </span><span style="color:${parseFloat(data.avg)>=3?'#00ff88':'#ff6b35'}">${data.avg}</span></span></div>`
  ).join('');
}

function generateProblem() {
  const enabled = Object.keys(activeCategories).filter(k => activeCategories[k]);
  if (enabled.length === 0) return;
  const cat = enabled[Math.floor(Math.random() * enabled.length)];
  problem = { ...CATEGORIES[cat].generate(), category: cat };
  showGraph = false;
  drawingPoints = [];
  selfScore = null;
  draw();
  updateUI();
}

// Config
function buildCatButtons() {
  const container = document.getElementById('catButtons');
  const enabledCount = Object.values(activeCategories).filter(Boolean).length;
  document.getElementById('catCount').textContent = `FUNCTION TYPES (${enabledCount}/${Object.keys(CATEGORIES).length})`;
  container.innerHTML = '';
  Object.entries(CATEGORIES).forEach(([key, val]) => {
    const btn = document.createElement('button');
    btn.className = 'cat-btn' + (activeCategories[key] ? ' active' : '');
    btn.textContent = val.name;
    btn.onclick = () => { activeCategories[key] = !activeCategories[key]; buildCatButtons(); };
    container.appendChild(btn);
  });
}

document.getElementById('configBtn').onclick = () => {
  settingsOpen = !settingsOpen;
  document.getElementById('settings').classList.toggle('open', settingsOpen);
  document.getElementById('configBtn').textContent = settingsOpen ? 'CLOSE' : 'CONFIG';
  buildCatButtons();
  updateBreakdown();
};

document.getElementById('clearBtn').onclick = () => { drawingPoints = []; draw(); };
document.getElementById('revealBtn').onclick = () => { showGraph = true; draw(); updateUI(); };
document.getElementById('nextBtn').onclick = generateProblem;

// Rate buttons
const rateContainer = document.getElementById('rateButtons');
[1,2,3,4,5].forEach(n => {
  const btn = document.createElement('button');
  btn.className = 'rate-btn ' + (n <= 2 ? 'low' : n === 3 ? 'mid' : 'high');
  btn.textContent = n;
  btn.onclick = () => {
    selfScore = n;
    history.unshift({ equation: problem.equation, category: problem.category, score: n, time: Date.now() });
    if (history.length > 100) history.pop();
    updateUI();
  };
  rateContainer.appendChild(btn);
});

// Keyboard shortcut
document.addEventListener('keydown', e => {
  if (e.key === ' ' || e.key === 'Enter') {
    e.preventDefault();
    if (!showGraph) { showGraph = true; draw(); updateUI(); }
    else if (selfScore !== null) generateProblem();
  }
  if (showGraph && selfScore === null && e.key >= '1' && e.key <= '5') {
    const n = parseInt(e.key);
    selfScore = n;
    history.unshift({ equation: problem.equation, category: problem.category, score: n, time: Date.now() });
    if (history.length > 100) history.pop();
    updateUI();
  }
});

// Init
generateProblem();

// Register service worker for PWA
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js').catch(() => {});
}
</script>
</body>
</html>
